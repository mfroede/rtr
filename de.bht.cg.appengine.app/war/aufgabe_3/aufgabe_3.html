<!--
A WebGL example using tdl.js (http:// code.google.com/p/threedlibrary/).

author: Henrik Tramberend (tramberend@beuth-hochschule.de)
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>WebGL using tdl.js</title>
<script type="text/javascript" src="../resources/tdl/base.js"></script>
<script type="text/javascript" src="../resources/tdl/gl-matrix.js"></script>

<script src="../resources/common/jquery-1.7.1.min.js"></script>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- <link rel="stylesheet" type="text/css" href="../resources/common/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../resources/common/bootstrap/css/b1234ootstrap-responsive.min.css"> -->
<link rel="stylesheet" href="../resources/css/style.css" />

<script type="text/javascript" src="aufgabe_3.js"></script>
</head>

<body>

   <input class='backButton' type="button" value="back" onclick="javascript:history.back()">
   <div class="subpagetitle"
      style='opacity: 0.8; margin-left: auto; margin-right: auto; display: block; text-align: center; position: relative;'>Aufgabe
      3: WebGL Illuminated Spheres</div>
   <canvas id="canvas" width="800" height="450" style='margin-left: auto; margin-right: auto; display: block;'></canvas>

   <div class='slide-content' style='margin-left: auto; margin-right: auto; display: block;'>
      <div class='slide-description' style='width: 800px; display: block; margin-left: auto; margin-right: auto;'>
         <h3 style='margin: 15px 15px;'>Erläuterung des Lösungsansatzes</h3>

      </div>
   </div>

   <div class="container">
      <div class="page-header">
         <h1>WebGL Illuminated Spheres</h1>
      </div>

      <pre id="error" class="alert alert-error"></pre>



      <h2>Usage</h2>
      <ul>
         <li>Use keys <span class="label">0</span> - <span class="label">4</span> to switch between shader
            programs.
         </li>
         <li>Use <span class="label label-warning">S</span> to toggle animation.
         </li>
      </ul>

      <h2>Resources</h2>
      <ul>
         <li>Uses <a href="http://code.google.com/p/threedlibrary/">TDL</a> as a low-level WebGL support library.
         </li>
      </ul>
   </div>
</body>

<!--cell shader -->

<script id="vs4" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 lightPosition;
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  lightDirectionW = lightPosition - positionW.xyz;
  eyeDirectionW = eyePosition - positionW.xyz;

  gl_Position = projection * view * positionW;
}
</script>

<script id="fs4" type="text/glsl">
precision highp float;

uniform vec3 color;
uniform vec3 lightIntensity;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;

vec3 toon(vec3 normal, vec3 eye, vec3 light) {
    float sil = max(dot(eye, normal), 0.0);
    float intensity = max(dot(light, normal), 0.0);
    if(intensity < 0.2 || sil < 0.2) {
        return vec3(0.0, 0.0, 0.0);
    }
    vec3 resultColor;
    float specular = pow(max(0.0, dot(normal,light)), 30.0);
    if (specular < 0.2) {
        resultColor = color * 0.8;
	} else {
		resultColor = lightIntensity;
	}
	float diffuse = dot(normal,light);
   	if (diffuse < 0.5) {
		resultColor *= 0.8;
	}
	return resultColor;
}

void main() {
  vec3 color = toon(normalize(normalW), normalize(eyeDirectionW), normalize(lightDirectionW));

  gl_FragColor = vec4(color, 1.0);
}
</script>
<!--EOF: cell shader -->

<!-- Constant color -->
<script id="vs0" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

attribute vec4 position;

void main() {
  gl_Position = projection * view * model * position;
}
</script>

<script id="fs0" type="text/glsl">
precision highp float;

uniform vec3 color;

void main() {
  gl_FragColor.rgb = 0.7 * color;
  gl_FragColor.a = 1.0;
}
</script>

<!-- Lambert lighting model, Gouraud shading -->

<script id="vs1" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 color;
uniform vec3 lightIntensity;
uniform vec3 lightPosition;
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 intensity;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

void main() {
  vec3 normalW = (model * vec4(normal, 0.0)).xyz;
  vec4 positionW = model * position;
  vec3 lightDirectionW = normalize(lightPosition - positionW.xyz);

  intensity = lambert(normalW, lightDirectionW, lightIntensity, color);
  gl_Position = projection * view * positionW;
}
</script>

<script id="fs1" type="text/glsl">
precision highp float;

varying vec3 intensity;

void main() {
  gl_FragColor.rgb = intensity;
  gl_FragColor.a = 1.0;
}
</script>

<!-- Phong lighting model, Gouraud shading -->

<script id="vs2" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 color;
uniform vec3 lightIntensity;
uniform vec3 lightPosition;
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 intensity;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * 
         max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
  vec3 normalW = (model * vec4(normal, 0.0)).xyz;
  vec4 positionW = model * position;
  vec3 lightDirectionW = normalize(lightPosition - positionW.xyz);
  vec3 eyeDirectionW = normalize(eyePosition - positionW.xyz);

  intensity = phong(normalW, eyeDirectionW, lightDirectionW, 
                    lightIntensity, color);
  gl_Position = projection * view * positionW;
}
</script>

<script id="fs2" type="text/glsl">
precision highp float;

varying vec3 intensity;

void main() {
  gl_FragColor.rgb = intensity;
  gl_FragColor.a = 1.0;
}
</script>

<!-- Phong lighting model, Phong shading -->

<script id="vs3" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 lightPosition;
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  lightDirectionW = lightPosition - positionW.xyz;
  eyeDirectionW = eyePosition - positionW.xyz;

  gl_Position = projection * view * positionW;
}
</script>

<script id="fs3" type="text/glsl">
precision highp float;

uniform vec3 color;
uniform vec3 lightIntensity;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
  gl_FragColor.rgb = phong(
    normalize(normalW), 
    normalize(eyeDirectionW), 
    normalize(lightDirectionW), 
    lightIntensity, color);
  gl_FragColor.a = 1.0;
}
</script>

<!-- Phong lighting model, Phong shading with texture -->

<script id="vs5" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 lightPosition;
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;
attribute vec2 texCoord;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  lightDirectionW = lightPosition - positionW.xyz;
  eyeDirectionW = eyePosition - positionW.xyz;

  texCoordI = texCoord;
  gl_Position = projection * view * positionW;
}
</script>

<script id="fs5" type="text/glsl">
precision highp float;

uniform vec3 lightIntensity;
uniform sampler2D earth;

varying vec3 normalW;
varying vec3 lightDirectionW;
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
  vec3 color = texture2D(earth, texCoordI).rgb;

  gl_FragColor.rgb = phong(
    normalize(normalW), 
    normalize(eyeDirectionW), 
    normalize(lightDirectionW), 
    lightIntensity, color);
  gl_FragColor.a = 1.0;
}
</script>

</html>
