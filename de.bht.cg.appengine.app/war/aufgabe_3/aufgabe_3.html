<!--
A WebGL example using tdl.js (http:// code.google.com/p/threedlibrary/).

author: Henrik Tramberend (tramberend@beuth-hochschule.de)
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>WebGL using tdl.js</title>
<script type="text/javascript" src="../resources/tdl/base.js"></script>
<script type="text/javascript" src="../resources/tdl/gl-matrix.js"></script>

<script src="../resources/common/jquery-1.7.1.min.js"></script>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- <link rel="stylesheet" type="text/css" href="../resources/common/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="../resources/common/bootstrap/css/b1234ootstrap-responsive.min.css"> -->
<link rel="stylesheet" href="../resources/css/style.css" />

<script type="text/javascript" src="aufgabe_3.js"></script>
<script type="text/javascript" src="light.js"></script>
</head>

<body>

   <input class='backButton' type="button" value="back" onclick="javascript:history.back()">
   <div class="subpagetitle"
      style='opacity: 0.8; margin-left: auto; margin-right: auto; display: block; text-align: center; position: relative;'>Aufgabe
      3: WebGL Illuminated Spheres</div>
   <canvas id="canvas" width="800" height="450" style='margin-left: auto; margin-right: auto; display: block;'></canvas>

    <div class='slide-content' style='margin-left: auto; margin-right: auto; display: block;'>
      <div class='slide-description' style='width: 800px; display: block; margin-left: auto; margin-right: auto;'>
         <h3 style='margin: 15px 15px;'>Bedienung der Anwendung</h3>
         <div style="display:-webkit-box; -webkit-box-orient:horizontal;">
         <div style=" -webkit-box-flex:1;">
         <p>Number of Circle: <input id="circlenumber" onchange='render()' value="5" size="2" maxlength="5" type="text"></input></p>
         <p>Radius of Circle: <input id="circleradius" onchange='render()' value="0.8" size="2" maxlength="5" type="text"></input></p>
         <p>Color of Circle: <input id="circlecolor" onchange='render()' value="255, 0, 0" size="5" maxlength="50" type="text"></input></p>
         <p>Color of Cube: <input id="cubecolor" onchange='render()' value="0, 0, 255" size="5" maxlength="50" type="text"></input></p>
         <p>Edge length of Cube: <input id="cubelength" onchange='initialize()' value="0.7" size="2" maxlength="5" type="text"></input></p>
         </div>
        <div style=" -webkit-box-flex:1;">
         <p>"q-u"   - Verschiedene Shadertypen</p>
         <p>"y,x,c" - Wechseln zwischen verschiedenen Modellen</p>
         <p>"a"     - Gepunktete Textur auf der Oberfläche an/aus</p>
         <p>"s"     - Ein-/Ausschalten der Rotation</p>        
        </div>
        </div>       
      </div>
   </div>

   <div class='slide-content' style='margin-left: auto; margin-right: auto; display: block;'>
      <div class='slide-description' style='width: 800px; display: block; margin-left: auto; margin-right: auto;'>
         <h3 style='margin: 15px 15px;'>Erläuterung des Lösungsansatzes</h3>

      </div>
   </div>

   <div class="container">
      <div class="page-header">
         <h1>WebGL Illuminated Spheres</h1>
      </div>

      <pre id="error" class="alert alert-error"></pre>



      <h2>Usage</h2>
      <ul>
         <li>Use keys <span class="label">0</span> - <span class="label">4</span> to switch between shader
            programs.
         </li>
         <li>Use <span class="label label-warning">S</span> to toggle animation.
         </li>
      </ul>

      <h2>Resources</h2>
      <ul>
         <li>Uses <a href="http://code.google.com/p/threedlibrary/">TDL</a> as a low-level WebGL support library.
         </li>
      </ul>
   </div>
</body>

<!--cell shader -->

<script id="vs4" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model; 
uniform float time;

uniform vec3 lightPositions[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;
attribute vec2 texCoord;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  for(int i=0; i<4; i++) {
    lightDirectionsW[i] = lightPositions[i] - positionW.xyz;
  }
  eyeDirectionW = eyePosition - positionW.xyz;

  gl_Position = projection * view * positionW;
  texCoordI = texCoord;
}
</script>

<script id="fs4" type="text/glsl">
precision highp float;

uniform vec3 color;
uniform vec3 lightIntensities[4];
uniform float radius;
uniform float number;
uniform vec3 circleColor;
uniform vec3 backround;
uniform bool circleTexture;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

vec3 toon(vec3 normal, vec3 eye, vec3 light, vec3 lightIntensity, vec3 color) {
    float sil = dot(eye, normal);
    float intensity = max(dot(light, normal), 0.0);
    if(intensity < 0.2 || abs(sil) < 0.3) {
        return vec3(0.0, 0.0, 0.0);
    }
    vec3 resultColor;
    float specular = pow(max(0.0, dot(normal,light)), 30.0);
    if (specular < 0.2) {
        resultColor = color * 0.8;
	} else {
		resultColor = lightIntensity;
	}
	float diffuse = dot(normal,light);
   	if (diffuse < 0.5) {
		resultColor *= 0.8;
	}
	return resultColor * lightIntensity;
}

float oscillation(float x, float num){    
    return 2.0 / 3.14159 * asin(cos(3.14159 * x * num));
}

vec3 generateColor(){
    if(oscillation(texCoordI.x, number) * oscillation(texCoordI.x, number) + oscillation(texCoordI.y, number) * oscillation(texCoordI.y, number) <= radius * radius){
        return circleColor;
    } else {
        return backround;
    }
}

void main() {
    vec3 formColor = color;
    if(circleTexture){
        formColor = generateColor();
    }  

    vec3 newcolor = vec3(0,0,0);

    for(int i = 0; i < 4; i++) {
       newcolor +=  toon(normalize(normalW), normalize(eyeDirectionW), normalize(lightDirectionsW[i]), lightIntensities[i],  formColor);
    }
    gl_FragColor = vec4(newcolor, 1.0);
}
</script>
<!--EOF: cell shader -->

<!--Wave shader -->
<script id="vs5" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model; 
uniform float time;

uniform vec3 lightPositions[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;

float pi2 = asin(1.0);

float wave(float x, float t, float A, float f, float c, float p0) {
    return A * sin(pi2 * f * (t - x/c) + p0);
}

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  for(int i=0; i<4; i++) {
    lightDirectionsW[i] = lightPositions[i] - positionW.xyz;
  }
  eyeDirectionW = eyePosition - positionW.xyz;

  vec3 direction = normalize(vec3(0.0, 1.0, 0.0));
  float projected = dot(direction, position.xyz);
  float displacement = wave(projected, time, 0.2, 1.0, -1.0, 0.0);
  vec3 trans = positionW.xyz + vec3(positionW.z * displacement, positionW.x * displacement, positionW.y * displacement);

  gl_Position = projection * view * vec4(trans.xyz, 1.0);
}
</script>

<script id="fs5" type="text/glsl">
precision highp float;

uniform vec3 color;
uniform vec3 lightIntensities[4];

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
vec3 newCcolor = vec3(0,0,0);
   for(int i = 0; i < 4; i++) {
     newCcolor += phong(
             normalize(normalW), 
             normalize(eyeDirectionW), 
             normalize(lightDirectionsW[i]), 
             lightIntensities[i], color) * lightIntensities[i];
   }
  gl_FragColor.rgb = newCcolor.rgb;
  gl_FragColor.a = 1.0;
}
</script>
<!--EOF: Wave shader -->

<!-- Constant color -->
<script id="vs0" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

attribute vec4 position;

void main() {
  gl_Position = projection * view * model * position;
}
</script>

<script id="fs0" type="text/glsl">
precision highp float;

uniform vec3 color;

void main() {
  gl_FragColor.rgb = 0.7 * color;
  gl_FragColor.a = 1.0;
}
</script>
<!-- EOF Constant color -->

<!-- Lambert lighting model, Gouraud shading -->
<script id="vs1" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 color;
uniform vec3 lightIntensities[4];
uniform vec3 lightPositions[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 intensity;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

void main() {
  vec3 normalW = (model * vec4(normal, 0.0)).xyz;
  vec4 positionW = model * position;
  for(int i=0; i<4; i++) {
    vec3 lightDirectionW = normalize(lightPositions[i] - positionW.xyz);
    intensity += lambert(normalW, lightDirectionW, lightIntensities[i], color);
  }

  gl_Position = projection * view * positionW;
}
</script>

<script id="fs1" type="text/glsl">
precision highp float;

varying vec3 intensity;

void main() {
  gl_FragColor.rgb = intensity;
  gl_FragColor.a = 1.0;
}
</script>
<!-- EOF Lambert lighting model, Gouraud shading -->

<!-- Phong lighting model, Gouraud shading -->
<script id="vs2" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 color;
uniform vec3 lightIntensities[4];
uniform vec3 lightPositions[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 intensity;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * 
         max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
  vec3 normalW = (model * vec4(normal, 0.0)).xyz;
  vec4 positionW = model * position;
  vec3 eyeDirectionW = normalize(eyePosition - positionW.xyz);
  for(int i=0; i<4; i++) {
    vec3 lightDirectionW = normalize(lightPositions[i] - positionW.xyz);
    intensity += phong(normalW, eyeDirectionW, lightDirectionW, 
                       lightIntensities[i], color);
  }

  gl_Position = projection * view * positionW;
}
</script>

<script id="fs2" type="text/glsl">
precision highp float;

varying vec3 intensity;

void main() {
  gl_FragColor.rgb = intensity;
  gl_FragColor.a = 1.0;
}
</script>
<!-- EOF Phong lighting model, Gouraud shading -->

<!-- Phong lighting model, Phong shading -->
<script id="vs3" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 lightPositions[4];
uniform vec3 lightIntensities[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  for(int i=0; i<4; i++) {
    lightDirectionsW[i] = normalize(lightPositions[i] - positionW.xyz);
  }
  eyeDirectionW = eyePosition - positionW.xyz;

  gl_Position = projection * view * positionW;
}
</script>

<script id="fs3" type="text/glsl">
precision highp float;

uniform vec3 color;
uniform vec3 lightIntensities[4];

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
   vec3 newColor = vec3(0,0,0);
   for(int i = 0; i < 4; i++) {
     newColor += phong(
             normalize(normalW), 
             normalize(eyeDirectionW), 
             normalize(lightDirectionsW[i]), 
             lightIntensities[i], color);
   }
   gl_FragColor.rgb = newColor;
   gl_FragColor.a = 1.0;
}
</script>
<!-- EOF Phong lighting model, Phong shading -->

<!-- Phong lighting model, Phong shading with texture -->
<script id="vs5" type="text/glsl">
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

uniform vec3 lightPositions[4];
uniform vec3 eyePosition;

attribute vec4 position;
attribute vec3 normal;
attribute vec2 texCoord;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

void main() {
  vec4 positionW = model * position;
  normalW = (model * vec4(normal, 0.0)).xyz;
  for(int i=0; i<4; i++) {
    lightDirectionsW[i] = lightPositions[i] - positionW.xyz;
  }
  eyeDirectionW = eyePosition - positionW.xyz;

  texCoordI = texCoord;
  gl_Position = projection * view * positionW;
}
</script>

<script id="fs5" type="text/glsl">
precision highp float;

uniform vec3 lightIntensities[4];
uniform sampler2D earth;

varying vec3 normalW;
varying vec3 lightDirectionsW[4];
varying vec3 eyeDirectionW;
varying vec2 texCoordI;

vec3 lambert(vec3 normal, vec3 light, 
             vec3 intensity, vec3 reflectivity) {
  return 0.1 * reflectivity * intensity +
         0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
}

vec3 phong(vec3 normal, vec3 eye, vec3 light, 
           vec3 intensity, vec3 reflectivity) {
  return lambert(normal, light, intensity, reflectivity) +
         0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), 
                                      light)), 10.0);
}

void main() {
  vec3 newColor = texture2D(earth, texCoordI).rgb;
  for(int i = 0; i < 4; i++) {
     newColor += phong(
             normalize(normalW), 
             normalize(eyeDirectionW), 
             normalize(lightDirectionsW[i]), 
             lightIntensities[i], newColor);
  }
  gl_FragColor.rgb = newColor;
  gl_FragColor.a = 1.0;
}
</script>
<!-- EOF Phong lighting model, Phong shading with texture -->
</html>
